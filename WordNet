package a06;

import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.Queue;
import edu.princeton.cs.algs4.SeparateChainingHashST;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;

/**
 * 
 * @author Pace Wasden and Spencer Rosenvall
 *
 */
public class WordNet
{
	private SAP sap;
	private Digraph graph;
	private SeparateChainingHashST<String, Queue<Integer>> wordToInt;
	private SeparateChainingHashST<Integer, String> intToWord;

	// constructor takes the name of the two input files
	public WordNet(String synsets, String hypernyms)
	{
		if (synsets == null || hypernyms == null)
		{
			throw new NullPointerException("The passed arguments may not be null.");
		}

		In synIn = new In(synsets);
		In hypIn = new In(hypernyms);
		int verticesRead = 0;

		wordToInt = new SeparateChainingHashST<>();
		intToWord = new SeparateChainingHashST<>();

		while (synIn.hasNextLine())
		{
			// Reads in the vertices and stores it to the ST
			String[] line = synIn.readLine().split(",");
			String[] words = line[1].split(" ");
			Integer number = Integer.valueOf(line[0]);
			intToWord.put(Integer.valueOf(line[0]), line[1]);
			verticesRead++;

			for (int i = 0; i < words.length; i++)
			{
				Queue<Integer> wordToIntQueue = wordToInt.get(words[i]);

				if (wordToIntQueue != null)
				{
					if (!contains(wordToIntQueue, number))
					{
						wordToIntQueue.enqueue(number);
					}
				} else
				{
					wordToIntQueue = new Queue<>();
					wordToIntQueue.enqueue(number);
					wordToInt.put(words[i], wordToIntQueue);
				}
			}
		}

		graph = new Digraph(verticesRead);

		while (hypIn.hasNextLine())
		{
			String[] line = hypIn.readLine().split(",");
			for (int i = 1; i < line.length; i++)
			{
				graph.addEdge(Integer.parseInt(line[0]), Integer.parseInt(line[i]));
			}
		}

		sap = new SAP(graph);
		// if (!sap.isRootedDAG())
		// {
		// throw new IllegalArgumentException("The hypernyms passed must be a
		// rooted DAG.");
		// }
	}

	// returns all WordNet nouns
	public Iterable<String> nouns()
	{
		return wordToInt.keys();
	}

	// is the word a WordNet noun?
	public boolean isNoun(String word)
	{
		if (word == null)
		{
			throw new NullPointerException("The passed arguments may not be null.");
		}
		return wordToInt.contains(word);
	}

	// distance between nounA and nounB (defined below)
	public int distance(String nounA, String nounB)
	{
		if (nounA == null || nounB == null)
		{
			throw new NullPointerException("The passed arguments may not be null.");
		}

		if (wordToInt.get(nounA) == null || wordToInt.get(nounB) == null)
		{
			throw new IllegalArgumentException("The nouns passed must be included within the wordnet.");
		}

		Iterable<Integer> intA = wordToInt.get(nounA);
		Iterable<Integer> intB = wordToInt.get(nounB);
		return sap.length(intA, intB);
	}

	// a synset (second field of synsets.txt) that is the common ancestor of
	// nounA and nounB
	// in a shortest ancestral path (defined below)
	public String sap(String nounA, String nounB)
	{
		if (nounA == null || nounB == null)
		{
			throw new NullPointerException("The passed arguments may not be null.");
		}

		if (wordToInt.get(nounA) == null || wordToInt.get(nounB) == null)
		{
			throw new IllegalArgumentException("The nouns passed must be included within the wordnet.");
		}

		Iterable<Integer> intA = wordToInt.get(nounA);
		Iterable<Integer> intB = wordToInt.get(nounB);
		return intToWord.get(sap.ancestor(intA, intB));
	}

	// Private method to iterate through a data structure and checks for a
	// specific item within it.
	private <Item> boolean contains(Iterable<Item> iterable, Item item)
	{
		for (Item el : iterable)
		{
			if (el == item)
			{
				return true;
			}
		}
		return false;
	}

	// do unit testing of this class
	public static void main(String[] args)
	{
		In in = new In(args[0]);
		Digraph G = new Digraph(in);
		SAP sap = new SAP(G);
		while (!StdIn.isEmpty()){
			int v = StdIn.readInt();
			int w = StdIn.readInt();
			int length = sap.length(v, w);
			int ancestor = sap.ancestor(v, w);
			StdOut.printf("length = %d, ancestor = %d\n", length, ancestor);
		}
	}
}

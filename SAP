package a06;

import java.util.ArrayList;

import edu.princeton.cs.algs4.BreadthFirstDirectedPaths;
import edu.princeton.cs.algs4.DepthFirstDirectedPaths;
import edu.princeton.cs.algs4.DepthFirstOrder;
import edu.princeton.cs.algs4.Digraph;
import edu.princeton.cs.algs4.DirectedCycle;
import edu.princeton.cs.algs4.Stack;

/**
 * 
 * @author Pace Wasden and Spencer Rosenvall
 *
 */
public class SAP {

	private Digraph graph;

	// constructor takes a digraph (not necessarily a DAG)
	public SAP(Digraph G) {
		if (G == null)
			throw new java.lang.NullPointerException("Diagraph cant be null");
		this.graph = G;

	}

	// is the digraph a directed acyclic graph?
	public boolean isDAG() {
		return !new DirectedCycle(graph).hasCycle();

	}

	// is the digraph a rooted DAG?
	public boolean isRootedDAG() {
		DepthFirstOrder dfO = new DepthFirstOrder(this.graph);
		Integer root = dfO.post().iterator().next();

		DepthFirstDirectedPaths dfP = new DepthFirstDirectedPaths(graph.reverse(), root);
		for (int i = 0; i < graph.V(); i++) {
			if (!dfP.hasPathTo(i))
				return false;
		}
		return true;
	}

	// length of shortest ancestral path between v and w; -1 if no such path
	public int length(int v, int w) {
		int root = 0;
		int length = -1;
		for (int i = 0; i < graph.V(); i++) {
			if (!graph.adj(i).iterator().hasNext())
				root = i;
		}

		Stack<Integer> vStack = new Stack<>();
		vStack.push(v);
		Stack<Integer> wStack = new Stack<>();
		wStack.push(w);
		Stack<Integer> v2Stack = new Stack<Integer>();
		for (int i = 0; i < vStack.size(); i++) {
			vStack.push(vStack.pop());
		}
		Stack<Integer> w2Stack = new Stack<Integer>();
		for (int i = 0; i < wStack.size(); i++) {
			w2Stack.push(wStack.pop());
		}

		while (!v2Stack.isEmpty()) {
			if (v2Stack.peek().equals(w2Stack.peek())) {
				v2Stack.pop();
				w2Stack.pop();
			} else
				break;
			length = v2Stack.size() + w2Stack.size();
		}
		return length;
	}

	// a common ancestor of v and w that participates in a shortest ancestral
	// path; -1 if no such path
	public int ancestor(int v, int w) {
		int root = 0;
		int small = -1;
		for (int i = 0; i < graph.V(); i++) {
			if (!graph.adj(i).iterator().hasNext())
				root = i;
		}

		Stack<Integer> vStack = new Stack<>();
		vStack.push(v);
		Stack<Integer> wStack = new Stack<>();
		wStack.push(w);
		Stack<Integer> v2Stack = new Stack<Integer>();
		for (int i = 0; i < vStack.size(); i++) {
			vStack.push(vStack.pop());
		}
		Stack<Integer> w2Stack = new Stack<Integer>();
		for (int i = 0; i < wStack.size(); i++) {
			w2Stack.push(wStack.pop());
		}

		while (!v2Stack.isEmpty()) {
			if (v2Stack.peek().equals(w2Stack.peek())) {
				v2Stack.pop();
				w2Stack.pop();
			}
			small = v2Stack.size() + w2Stack.size();
		}
		return small;
	}

	// length of shortest ancestral path between any vertex in v and any vertex
	// in w; -1 if no such path
	public int length(Iterable<Integer> v, Iterable<Integer> w) {
		int minDistance = Integer.MAX_VALUE;
		int l;
		for (int vItem : v) {
			for (int wItem : w) {
				l = length(vItem, wItem);
				if (l < minDistance)
					minDistance = l;
			}
		}
		return minDistance;
	}

	// a common ancestor that participates in shortest ancestral path; -1 if no
	// such path
	public int ancestor(Iterable<Integer> v, Iterable<Integer> w) {

		BreadthFirstDirectedPaths vbfs = new BreadthFirstDirectedPaths(graph, v);
		BreadthFirstDirectedPaths wbfs = new BreadthFirstDirectedPaths(graph, w);

		ArrayList<Integer> ancestors = new ArrayList<Integer>();

		for (int i = 0; i < graph.V(); i++) {
			if (vbfs.hasPathTo(i) && wbfs.hasPathTo(i)) {
				ancestors.add(i);
			}
		}

		int minDistance = Integer.MAX_VALUE;
		int minAncestor = -1;
		for (int n : ancestors) {
			int dist = vbfs.distTo(n) + wbfs.distTo(n);
			if (dist < minDistance) {
				minDistance = dist;
				minAncestor = n;
			}
		}

		return minAncestor;
	}
}
